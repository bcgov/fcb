
name: "DEV Deploy"

#TODO: once working change the event the action is associated to the one below
on:
  workflow_run:
    workflows: ["BUILDPackage", "build"]
    types: 
      - completed

# on: 
#   push:
#     branches: ['dev', 'smk-cdci']

jobs:
  deploydev:
    defaults:
      run:
        shell: bash
    runs-on: ubuntu-20.04
    env:
      OPENSHIFT_SERVER_URL: ${{secrets.OPENSHIFT_SERVER_URL}}
      OPENSHIFT_TOKEN_DEV: ${{secrets.OPENSHIFT_TOKEN_DEV}}
      GHCR_USER: ${{ secrets.GHCR_USER }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      RUN_GWA: true
      REVIEWERS: '["GuyTheFlower", "NicoledeGreef"]'
      MENTIONS: '["GuyTheFlower", "NicoledeGreef", "franTarkenton"]'
    steps:

    # Checking out code to get access to the openshift deploy template later on
    # could also reference the github url?
    - uses: actions/checkout@v2
      id: checkout
      if: env.OPENSHIFT_SERVER_URL != '' && env.OPENSHIFT_TOKEN_DEV != ''
      with:
        fetch-depth: 0

    # LOGGING INTO OC
    - name: OpenShift Login Action
      id: GHAOpenshiftTest
      uses: redhat-developer/openshift-actions@v1.1
      if: env.OPENSHIFT_SERVER_URL != '' &&  env.OPENSHIFT_TOKEN_DEV != ''
      with:
        version: '3.11.232'
        openshift_server_url: ${{ secrets.OPENSHIFT_SERVER_URL }}
        parameters: '{"apitoken": "${{ secrets.OPENSHIFT_TOKEN_DEV }}", "acceptUntrustedCerts": "true"}'
        cmd: 'version'

      # RETRIEVE THE IMAGE TAG and the ISSUE
    - name: Retrieve image tag, issue url, oc namespace
      id: retrieveimagetag
      if: env.OPENSHIFT_SERVER_URL != '' && env.OPENSHIFT_TOKEN_DEV != '' && env.GHCR_USER != '' && env.GHCR_TOKEN != ''
      run: |
        # summary of outputs created by this step:
        #   REPONAME
        #   EMAIL
        #   IMAGE_REGISTRY
        #   DOCKER_VERSION_TAG
        #   ISSUE_URL

        # calculate the repository name and export to other steps
        # ---------------------------------------------------------
        REPOANDORG=${{ github.repository }}
        REPONAME=$(basename "${REPOANDORG}")
        echo reponame $REPONAME
        echo ::set-output name=REPONAME::${REPONAME}

        # get the email address of the person who is defined in the secret GHCR_TOKEN
        # and export it for other steps
        # ---------------------------------------------------------
        EMAIL=$(curl -H "Accept: application/vnd.github.v3+json" \
                -H "Authorization: token $GHCR_TOKEN" \
                https://api.github.com/users/$GHCR_USER | jq '.email')
        echo ::set-output name=EMAIL::${EMAIL}

        # the path to the image registry
        # ---------------------------------------------------------
        IMAGE_REGISTRY=docker.pkg.github.com/${{ github.repository_owner }}/$REPONAME/$REPONAME
        echo ::set-output name=IMAGE_REGISTRY::${IMAGE_REGISTRY}

        # ---- get the oc namespace name and set the namespace, verify that the project
        #      that is being pointed to is the correct one or raise an error
        OC_NAMESPACE_NAMES_CONFIG_MAP=namespaces-cm
        OCDEVNAMESPACE=$(oc get configmap $OC_NAMESPACE_NAMES_CONFIG_MAP  -o json | jq .data.dev | tr -d '"')
        echo namespace $OCDEVNAMESPACE
        oc project $OCDEVNAMESPACE
        project=$(oc project --short=true)
        if [ "$project" != "$OCDEVNAMESPACE" ]
          then 
              exit 1
        fi

        # ---- retrieve the image tag from where it was cached in a configmap during the build
        #      stage, and exporting it to a variable so its available to other deployment
        #      steps
        # ---------------------------------------------------------
        IMAGE_TAG_CONFMAP_NAME=$REPONAME-imagetag-cm
        CONFMAPIMAGETAG=current_image_tag
        echo image name $IMAGE_TAG_CONFMAP_NAME
        IMAGE_TAG=$(oc get configmap $IMAGE_TAG_CONFMAP_NAME  -o json | jq .data.$CONFMAPIMAGETAG)
        echo ::set-output name=DOCKER_VERSION_TAG::${IMAGE_TAG}
        echo image tag $IMAGE_TAG
        
        # ---- Get the issue url and export it
        # ---------------------------------------------------------
        #ISSUE_CONFIGMAP_NAME=github-issues-configmap
        CONFMAPISSUEURLKEY=issueURL
        ISSUE_CONFIGMAP_NAME=$REPONAME-gh-issues-cm
        echo configmap name $ISSUE_CONFIGMAP_NAME
        ISSUE_URL=$(oc get configmap $ISSUE_CONFIGMAP_NAME  -o json | jq .data.$CONFMAPISSUEURLKEY)
        echo ISSUE_URL $ISSUE_URL
        echo ::set-output name=ISSUE_URL::${ISSUE_URL}

    - name: Deploy Helm chart
      id: deployHelm
      if: env.OPENSHIFT_SERVER_URL != '' && env.OPENSHIFT_TOKEN_DEV != '' && env.GHCR_USER != '' && env.GHCR_TOKEN != ''
      run: |
        # -- retrieving variables calculated in previous steps
        EMAIL=${{ steps.retrieveimagetag.outputs.EMAIL }}
        DOCKER_VERSION_TAG=${{ steps.retrieveimagetag.outputs.DOCKER_VERSION_TAG }}
        IMAGE_REGISTRY=${{ steps.retrieveimagetag.outputs.IMAGE_REGISTRY }}
        REPONAME=${{ steps.retrieveimagetag.outputs.REPONAME }}
        IMAGE_PULL_SECRET_NAME=${REPONAME}-image-pull-secret

        # -- debug-- verify the variables have been retrieved and have the values expected
        echo EMAIL $EMAIL
        echo REPONAME $REPONAME
        echo DOCKER_VERSION_TAG $DOCKER_VERSION_TAG
        echo IMAGE_REGISTRY $IMAGE_REGISTRY

        # potential issue:
        #  - helm chart creates the image pull secret
        #  - tries to use it with the service account
        #  - service account hasn't been granted access

        helm upgrade $REPONAME ./helm-charts --install \
           --set app_name=$REPONAME \
           --set env=dev \
           --set app_image_pull_secret_params.email=$EMAIL \
           --set app_image_pull_secret_params.password=$GHCR_TOKEN \
           --set app_image_pull_secret_params.name=$IMAGE_PULL_SECRET_NAME \
           --set app_image_pull_secret_params.imagetag=$DOCKER_VERSION_TAG \
           --set app_image_pull_secret_params.registry=$IMAGE_REGISTRY

        # verify / report on the image tag that was deployed
        IMAGE_DEPLOYED=$(oc get dc smk-fap-fcb-dc -o json | jq '.spec.template.spec.containers[0].image' | tr -d '"' )
        echo IMAGE_DEPLOYED $IMAGE_DEPLOYED
        IMAGE_DEPLOYED_TAG=$(echo ${IMAGE_DEPLOYED} | cut -d':' -f2)
        echo IMAGE_DEPLOYED_TAG $IMAGE_DEPLOYED_TAG

        # finally need to grant the service account access to the the 
        # image_pull_secret that was just created
        serviceAccountName=$(oc whoami | cut -d':' -f4)
        oc patch serviceaccount $serviceAccountName -p '{"imagePullSecrets": [{"name": "'$IMAGE_PULL_SECRET_NAME'"}]}'

    # # ADD THE ROUTE TO THE ISSUE
    - name: Update issue
      id: updateissue
      if: env.OPENSHIFT_SERVER_URL != '' && env.OPENSHIFT_TOKEN_DEV != '' && env.GHCR_TOKEN != ''
      run: |
        # populate env vars used by this step
        REPONAME=${{ steps.retrieveimagetag.outputs.REPONAME }}

        # retrieve the route url
        # ---------------------------------------------------------
        oc_route_name=$REPONAME-rt
        GITHUB_ISSUES_CONFIGMAP=$REPONAME-gh-issues-cm
        ROUTEPATH=$(oc get route $oc_route_name -o json | jq .spec.host | tr -d '"' )
        ROUTEURL=https://$ROUTEPATH

        # get the github issue url from the configmap
        # ---------------------------------------------------------
        echo the GITHUB_EVENT_PATH
        #cat $GITHUB_EVENT_PATH
        ISSUE_URL=$(oc get configmap $GITHUB_ISSUES_CONFIGMAP -o json | jq .data.issueURL | tr -d '"')
        echo ISSUE_URL $ISSUE_URL

        #format reviewers
        MENTION_STRING=$(echo $MENTIONS | jq -rc 'map("@" + .) | .[]' | tr '\n' ',' | sed 's/, */, /g' |  sed 's/, *$//g')

        # ADD COMMENT TO THE ISSUE
        echo 'adding route to the comment for the issue'
        GITHUB_TOKEN=${{ secrets.GHCR_TOKEN }}
        ISSUE_COMMENT="link to demo deployment of your smk based app is \n https://$ROUTEPATH\n\nVerify that it looks good, if so merge the pull request which will trigger a prod deployment, otherwise close the pull request without merging\n\n mentions / notifications: $MENTION_STRING"
        ISSUE_BODY='{"body": "'$ISSUE_COMMENT'"}'

        curl $ISSUE_URL -X POST --header "Authorization: Bearer $GITHUB_TOKEN" \
          --header "Accept: application/vnd.github.v3+json" \
          --data-raw "$ISSUE_BODY"
        
        echo ::set-output name=ISSUE_URL::${ISSUE_URL}

    - name: Get GWA CLI
      id: getGWACLI
      if: env.RUN_GWA == 'true' && env.OPENSHIFT_SERVER_URL != '' && env.OPENSHIFT_TOKEN_DEV != ''
      run: |

        # Grabbing the GWA command line tool
        #----------------------------------------------------
        GWA_VERSION=v1.1.2
        GWA_CLI_LINK=https://github.com/bcgov/gwa-cli/releases/download/${GWA_VERSION}/gwa_${GWA_VERSION}_linux_x64.zip
        curl -L -O $GWA_CLI_LINK
        unzip -p gwa_${GWA_VERSION}_linux_x64.zip > gwa-cli-linux
        chmod +x gwa-cli-linux
        
    - name: Configure Kong Route
      id: kongconf
      if: env.RUN_GWA == 'true' && env.OPENSHIFT_SERVER_URL != '' && env.OPENSHIFT_TOKEN_DEV != ''
      run: |

        # get the Reponame from previous step
        # ---------------------------------------------------
        REPONAME=${{ steps.retrieveimagetag.outputs.REPONAME }}

        # extract kong config info from secret objects
        # --------------------------------------------------
        kongSecrets=$(oc get secrets kong-secrets -o json | jq '.data' | jq '.["kong-config"] | @base64d | fromjson')
        GWA_CLIENTID=$(echo $kongSecrets | jq '.gwa_client_id')
        GWA_TOKEN=$(echo $kongSecrets | jq '.apikey')
        GWA_NAMESPACE=$(echo $kongSecrets | jq '.gwa_namespace')
        gwa_route_name=${REPONAME}-route
        oc_service_name=${REPONAME}-svc
        oc_service_port=$(oc get service ${oc_service_name} -o json | jq '.spec.ports[0].port')
        oc_project=$(oc project --short=true)

        # init the gwa config
        # --------------------------------------------------
        ./gwa-cli-linux init -T \
           --namespace=$GWA_NAMESPACE \
           --client-id=$GWA_CLIENTID \
           --client-secret=$GWA_TOKEN

        # create the gwa config
        # --------------------------------------------------
        python3 gwa/createGWAConfig.py \
          OCService=$oc_service_name \
          reponame=$REPONAME \
          OCNamespace=$oc_project \
          servicePort=$oc_service_port \
          kongDomain=api.gov.bc.ca
          GWANamespace=$GWA_NAMESPACE \
          GWAenv=dev > gwa_config.yaml

        # publish the gwa config
        # --------------------------------------------------
        ./gwa-cli-linux pg gwa_config.yaml

        # verify the url and output it
        # --------------------------------------------------

        # authenticate to api
        CREDS64=$(echo -ne "${GWA_CLIENTID}:${GWA_TOKEN}" | base64 -w 0 -)
        TOKEN=$(curl 'https://authz-apps-gov-bc-ca.test.apsgw.xyz/auth/realms/aps/protocol/openid-connect/token' \
          -H 'Accept: application/json, text/plain, */*'  \
          -H 'Content-Type: application/x-www-form-urlencoded'  \
          -H 'X-Requested-With: XMLHttpRequest'  \
          -H "Authorization: Basic ${CREDS64}" \
          -H 'Origin: https://gwa-api-gov-bc-ca.test.apsgw.xyz'  \
          -H 'Connection: keep-alive'  \
          --data-raw 'grant_type=client_credentials' \
          | jq '.access_token' | tr -d '"')
         
        # get the services in the namespace
        SERVICES=$(curl "https://gwa-api-gov-bc-ca.test.apsgw.xyz/v1/namespaces/${GWA_NAMESPACE}/services" \
          -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0' \
          -H 'Accept: */*' \
          -H 'Accept-Language: en-US,en;q=0.5' --compressed \
          -H "Authorization: Bearer ${TOKEN}" \
          -H 'Connection: keep-alive' )
        echo SERVICES $SERVICES

        # extract the url associated with the service
        function getUrl {
        python3 - <<END
        import json, sys, os
        jsonObj = json.loads(os.environ['SERVICES'])
        for obj in jsonObj:
            if obj['name'] == os.environ['OCService']:
                sys.stdout.write(f"https://{obj['env_host']}")
        END
        }
        export OCService
        echo OCService $OCService
        export SERVICES
        VANITY_URL=$(getUrl)
        echo vanity url $VANITY_URL
        echo ::set-output name=VANITY_URL::${VANITY_URL}

    - name: "Add Dev Vanity Url to Issue"
      id: addDevVanityUrlToIssue
      if: env.RUN_GWA == 'true' && env.OPENSHIFT_SERVER_URL != '' && env.OPENSHIFT_TOKEN_DEV != ''
      run: |
        ISSUEURL=${ steps.updateissue.outputs.ISSUEURL }
        VANITY_URL=${ steps.kongconf.outputs.VANITY_URL }
        REPONAME=${{ steps.retrieveimagetag.outputs.REPONAME }}
        MENTION_STRING=$(echo $MENTIONS | jq -rc 'map("@" + .) | .[]' | tr '\n' ',' | sed 's/, */, /g' |  sed 's/, *$//g')
        echo MENTION_STRING $MENTION_STRING
        ISSUECOMMENT="The Vanity URL for the Dev deploy is: $VANITY_URL, \n\n $MENTION_STRING"
        ISSUE_BODY='{"body": "'$ISSUE_COMMENT'"}'
        GITHUB_TOKEN=${{ secrets.GHCR_TOKEN }}
        curl $ISSUE_URL -X POST --header "Authorization: Bearer $GITHUB_TOKEN" \
          --header "Accept: application/vnd.github.v3+json" \
          --data-raw "$ISSUE_BODY"

    - name: "Send Review Request 2"
      id: requestreview
      if: env.OPENSHIFT_SERVER_URL != '' && env.OPENSHIFT_TOKEN_DEV != '' && env.GHCR_TOKEN != ''
      run: |
        # get the openshift dev namespace name
        OCDEVNAMESPACE=$(oc get configmap $OC_NAMESPACE_NAMES_CONFIG_MAP -o json | jq .data.dev | tr -d '"')
        REPONAME=${{ steps.retrieveimagetag.outputs.REPONAME }}
        CONFIGMAPNAME=$REPONAME-gh-issues-cm
        EVENT_INFO=$(oc get configmap $CONFIGMAPNAME -o json | jq '.data.github_event_json' | jq -rc)
        #GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}
        GITHUB_TOKEN=$GHCR_TOKEN

        # git_event.txt
        #EVENT_INFO=$(cat git_event.txt)

        # extract PR number from GH Action Event Info object
        # ---------------------------------------------------------
        PR_NUMBER=$(echo $EVENT_INFO | jq ".number")
        echo pr number is $PR_NUMBER
        PR_URL=$(echo $EVENT_INFO | jq ".pull_request.url" | tr -d '"')
        echo pr url is $PR_URL

        # configure reviewers - (should extract this from the repo)
        # ---------------------------------------------------------
        REVIEW_URL="$PR_URL/requested_reviewers"
        echo review url $REVIEW_URL
        # NicoledeGreef
        REVIEWERS='{"reviewers":'${REVIEWERS}' }'
        echo reviewers are $REVIEWERS

        curl --location --request POST  "$REVIEW_URL" \
        --header "Authorization: Bearer $GITHUB_TOKEN" \
        --header 'Content-Type: text/plain' \
        --data-raw "$REVIEWERS"
