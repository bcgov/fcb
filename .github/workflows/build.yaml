name: BUILDPackage

# Controls when the action will run. Triggers the workflow on push or pull request
# events but only for the master branch
# -------- DEBUGGING --------
# on: 
#   push:
#     branches: ['dev', 'smk-cdci']
#

on:
  pull_request:
    # debug: remove the dev,putting build action on non existent branches for debug
    branches: ['master']
    types: ['opened', 'reopened']
    paths-ignore:
      - openshift/**
      - .vscode/**
      - docs/**
      - .gitignore
      - LICENSE
      - open-api.json
      - readme.md
      - helm-charts
      - code_of_conduct.md

jobs:
  # This workflow contains a single job called "build"
  buildjob:
    defaults:
      run:
        shell: bash

    name: Build BCDC-SMK container image
    # The type of runner that the job will run on
    runs-on: ubuntu-18.04
    env:
      OPENSHIFT_SERVER_URL: ${{secrets.OPENSHIFT_SERVER_URL}}
      OPENSHIFT_TOKEN_DEV: ${{secrets.OPENSHIFT_TOKEN_DEV}}
      GHCR_USER: ${{ secrets.GHCR_USER }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      DEBUG_DEPLOY: false
    outputs:
      dockerversiontag: ${{ steps.calculateImageTag.outputs.DOCKER_VERSION_TAG }}
      
    steps:
    # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
    - uses: actions/checkout@v2
      if: env.DEBUG_DEPLOY == 'false'
      id: checkout
      with:
        fetch-depth: 0

    # Calculate the image tag, used later, and cached in a oc config map
    # if oc secrets provided
    - name: calculateImageTag
      id: calculateImageTag
      if: env.DEBUG_DEPLOY == 'false'
      run: |
        repoandorg=${{ github.repository }}
        REPO=$(basename "$repoandorg")
        echo REPO $REPO

        DATESTAMP=$(date +%Y%m%d-%H%M)
        REGISTRY="docker.pkg.github.com"
        IMAGE="${REGISTRY}/${{ github.repository }}/$REPO"
        TAGS="${IMAGE}:${DATESTAMP}"
        LATEST="${IMAGE}:latest"
        
        echo ::set-output name=DOCKER_VERSION_TAG::${TAGS}
        echo ::set-output name=DOCKER_LATEST_TAG::${LATEST}
        echo ::set-output name=TIMESTAMPTAG::${DATESTAMP}
        echo ::set-output name=REPO::${REPO}

        
        echo event name is $GITHUB_EVENT_NAME
        echo  $DEBUG_DEPLOY

    # Log into openshift
    - name: OpenShift Action
      id: GHAOpenshiftTest
      uses: redhat-developer/openshift-actions@v1.1
      if: env.OPENSHIFT_SERVER_URL != '' && env.OPENSHIFT_TOKEN_DEV != '' && env.DEBUG_DEPLOY == 'false'
      with:
        version: '3.11.232'
        openshift_server_url: ${{ secrets.OPENSHIFT_SERVER_URL }}
        parameters: '{"apitoken": "${{ secrets.OPENSHIFT_TOKEN_DEV }}", "acceptUntrustedCerts": "true"}'
        cmd: 'version'

    # --------- GET THE ISSUE URL and EVENT_INFO AND CACHE IT -------
    - name: Store Issue URL in configmap
      id: cacheIssueUrl
      if: github.event_name == 'pull_request' && env.OPENSHIFT_SERVER_URL != '' && env.OPENSHIFT_TOKEN_DEV != '' && env.DEBUG_DEPLOY == 'false'
      run: |
        echo github event name ${{ github.event_name }}
        echo CONFMAP_NAME $CONFMAP_NAME
        CONFMAP_NAME=${{ steps.calculateImageTag.outputs.REPO }}-gh-issues-cm
        echo CONFMAP_NAME $CONFMAP_NAME
        ISSUE_URL=$(jq --raw-output .pull_request.issue_url "$GITHUB_EVENT_PATH")
        echo issue url is $ISSUE_URL

        CONF_EXISTS=$(oc get configmaps -o json |  jq '[.items[] | select(.metadata.name == "'$CONFMAP_NAME'")] | length')
        echo CONF_EXISTS $CONF_EXISTS
        if [ $CONF_EXISTS -eq 0 ] 
          then
            methodType="create"
        else
            methodType="replace"
            oc delete configmap $CONFMAP_NAME
        fi
        
        oc create configmap $CONFMAP_NAME \
          --from-literal=issueURL=$ISSUE_URL \
          --from-literal=github_event_path=$GITHUB_EVENT_PATH \
          --from-file=github_event_json=$GITHUB_EVENT_PATH 

        # when 
        # oc create configmap $CONFMAP_NAME \
        #   --from-literal=issueURL=$ISSUE_URL \
        #   --from-literal=github_event_path=$GITHUB_EVENT_PATH \
        #   --from-file=github_event_json=$GITHUB_EVENT_PATH \
        #   --dry-run -o yaml | oc $methodType -f -

    # --------- required by build-push-action
    - name: Set up QEMU
      if: env.DEBUG_DEPLOY == 'false'
      uses: docker/setup-qemu-action@v1
    
    # --------- required by build-push-action
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v1
      if: env.DEBUG_DEPLOY == 'false' && success()
      with:
        buildkitd-flags: --debug

    # --------- required by build-push-action
    # - explicitly setting the GHCR_USER and TOKEN to help with transition to GHCR.IO
    - name: Login to GitHub Packages Docker Registry
      uses: docker/login-action@v1
      if: success() && env.GHCR_USER != '' && env.GHCR_TOKEN != '' && env.DEBUG_DEPLOY == 'false'
      with:
        registry: docker.pkg.github.com
        username: ${{ secrets.GHCR_USER }}
        password: ${{ secrets.GHCR_TOKEN }}

    # --------- Build image
    #    Push disabled because not working with this action atm
    - name: Build and push
      id: docker_build
      if: success() && env.GHCR_USER != '' && env.GHCR_TOKEN != '' && env.DEBUG_DEPLOY == 'false'
      uses: docker/build-push-action@v2
      with:
        context: .
        tags: |
          ${{ steps.calculateImageTag.outputs.DOCKER_VERSION_TAG }}
          ${{ steps.calculateImageTag.outputs.DOCKER_LATEST_TAG }}
        load: true

    # --------- Push image to remote
    - name: Push to Github Packages
      if: success() && env.GHCR_USER != '' && env.GHCR_TOKEN != '' && env.DEBUG_DEPLOY == 'false'
      run: |
        echo pushing the image
        echo $GITHUB_EVENT_NAME
        echo ${{ github.event_name }}

        # ---- commented out until pipeline goes to prod.
        docker push ${{ steps.calculateImageTag.outputs.DOCKER_VERSION_TAG }}

    # --------- cache the image tag in a oc config map
    - name: cacheImageTag
      id: cacheImageTag
      if: success() && env.OPENSHIFT_SERVER_URL != '' && env.OPENSHIFT_TOKEN_DEV != '' && env.DEBUG_DEPLOY == 'false'
      run: |
        IMAGETAG=${{ steps.calculateImageTag.outputs.TIMESTAMPTAG }}
        # needs to be made unique to app being deployed
        # CONFMAP_NAME=imagetag2deploy
        CONFMAP_NAME=${{ steps.calculateImageTag.outputs.REPO }}-imagetag-cm
        CONF_EXISTS=$(oc get configmaps -o json |  jq '[.items[] | select(.metadata.name == "'$CONFMAP_NAME'")] | length')
        echo conf exists is $CONF_EXISTS
        echo imagetag is $IMAGETAG
        
        if [ $CONF_EXISTS -eq 0 ] 
          then
            methodType="create"
        else
            methodType="replace"
        fi
        echo methodType is $methodType
        oc create configmap $CONFMAP_NAME --from-literal=current_image_tag=$IMAGETAG --dry-run -o yaml > template.yaml
        oc $methodType -f template.yaml

        # to retrieve the config map later:
        #   VAR=$(oc get configmap $CONFMAP_NAME  -o json | jq .data.current_image_tag)

    # -------- Update the issue --------
    # only update if:
    #    event type is pr
    #    secrets for github user / token populated
    - name: Tag the pull request with build tag
      id: tagpullrequest
      if: github.event_name == 'pull_request' && env.GHCR_USER != '' && env.GHCR_TOKEN != '' && env.DEBUG_DEPLOY == 'false'
      run: |
        DOCKER_VERSION_TAG=${{ steps.calculateImageTag.outputs.TIMESTAMPTAG }}

        echo tag version is $DOCKER_VERSION_TAG
        #pull_number=$(jq --raw-output .pull_request.number "$GITHUB_EVENT_PATH")
        echo github event path: $GITHUB_EVENT_PATH
        echo $GITHUB_WORKSPACE

        # use this for pulls
        issue_url=$(jq --raw-output .pull_request.issue_url "$GITHUB_EVENT_PATH")
        echo issue url is $issue_url

        # for debugging using existing pull_request
        if [ -z "$issue_url" ] || [ "$issue_url" = "null" ]
          then
            issue_url="https://api.github.com/repos/bcgov/smk-fap-fcb/issues/4"
        fi

        # ---- adding the tag that was assigned to the image to the issue ----
        jsonwithlabels=$(curl --header "Content-Type: application/json" \
        --header "authorization: Bearer ${{ secrets.GHCR_TOKEN }}" \
        --request GET \
        $issue_url | jq '.labels |= . + ["'$DOCKER_VERSION_TAG'"] | {("labels"): .["labels"]?}')
        
        # now send modified json back to the api with the new label
        curl \
        --location --request POST $issue_url \
        --header "Content-Type: application/json" \
        --header "authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
        --data "$jsonwithlabels"
