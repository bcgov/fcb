# This action should:
#  - trigger on merge of pr
#  - tag the master with the image tag
#  - deploy to prod
#
# https://github.community/t/run-action-only-when-a-pr-is-merged/18268

# name: DEPLOYProd
# on:
#   pull_request:
#     branches: 
#       - master
#     types: 
#       - closed
      
# debugging
on: 
  push:
    branches: ['dev', 'smk-cdci']

jobs:
  deployprod:

    # Commented out for testing
    if: github.event.pull_request.merged == true
    defaults:
      run:
        shell: bash
    runs-on: ubuntu-20.04
    steps:
    
    # CHECKOUT THE CODE
    - uses: actions/checkout@v2
      id: checkout
      with:
        fetch-depth: 0

    # LOGGING INTO OC DEV
    - name: OpenShift Action
      id: GHAOCAuthenticationPrd
      uses: redhat-developer/openshift-actions@v1.1
      with:
        version: '3.11.232'
        openshift_server_url: ${{ secrets.OPENSHIFT_SERVER_URL }}
        parameters: '{"apitoken": "${{ secrets.OPENSHIFT_TOKEN_DEV }}", "acceptUntrustedCerts": "true"}'
        cmd: 'version'

    # GETTING THE IMAGE TAG FROM DEV OC
    - name: Retrieve tag from the artifacts
      id: retrieveimagetag
      run: |
        # outputs:
        # --------------------------------------------------------
        # steps.retrieveimagetag.outputs.REPONAME
        # steps.retrieveimagetag.outputs.IMAGE_TAG
        # steps.retrieveimagetag.outputs.DOCKER_VERSION_TAG
        # steps.retrieveimagetag.outputs.IMAGE_REGISTRY
        #
        # Calculate the repo name
        # --------------------------------------------------------
        REPOANDORG=${{ github.repository }}
        REPONAME=$(basename "${REPOANDORG}")
        echo reponame $REPONAME
        echo ::set-output name=REPONAME::${REPONAME}

        # the path to the image registry
        # ---------------------------------------------------------
        IMAGE_REGISTRY=docker.pkg.github.com/${{ github.repository_owner }}/$REPONAME/$REPONAME
        echo ::set-output name=IMAGE_REGISTRY::${IMAGE_REGISTRY}

        # retrieve the image tag from the configmap in the dev 
        # namespace
        # --------------------------------------------------------
        IMAGE_TAG_CONFMAP_NAME=$REPONAME-imagetag-cm
        CONFMAPIMAGETAG=current_image_tag
        echo image name $IMAGE_TAG_CONFMAP_NAME
        IMAGE_TAG=$(oc get configmap $IMAGE_TAG_CONFMAP_NAME  -o json | jq .data.$CONFMAPIMAGETAG)
        echo ::set-output name=DOCKER_VERSION_TAG::${IMAGE_TAG}
        echo image tag $IMAGE_TAG

        # ---- retrieve the image tag from where it was cached in a configmap during the build
        #      stage, and exporting it to a variable so its available to other deployment
        #      steps
        # ---------------------------------------------------------
        IMAGE_TAG_CONFMAP_NAME=$REPONAME-imagetag-cm
        CONFMAPIMAGETAG=current_image_tag
        echo image name $IMAGE_TAG_CONFMAP_NAME
        IMAGE_TAG=$(oc get configmap $IMAGE_TAG_CONFMAP_NAME  -o json | jq .data.$CONFMAPIMAGETAG)
        echo ::set-output name=DOCKER_VERSION_TAG::${IMAGE_TAG}
        echo image tag $IMAGE_TAG


    # APPLY THE RELEASE TAG TO THE MERGED COMMIT
    - name: Apply the tag
      id: applyreleasetag
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GHCR_TOKEN }} # This token is provided by Actions, you do not need to create your own token
      with:
        tag_name: ${{ steps.retrieveimagetag.outputs.DOCKER_VERSION_TAG }}
        release_name: Release ${{ steps.retrieveimagetag.outputs.DOCKER_VERSION_TAG }}
        body: |
          automatically created release tag
        draft: false
        prerelease: false
    
    # LOGGING INTO OC PROD
    - name: OpenShift Action
      id: GHAOCAuthenticationPrd
      uses: redhat-developer/openshift-actions@v1.1
      with:
        version: '3.11.232'
        openshift_server_url: ${{ secrets.OPENSHIFT_SERVER_URL }}
        parameters: '{"apitoken": "${{ secrets.OPENSHIFT_TOKEN_PROD }}", "acceptUntrustedCerts": "true"}'
        cmd: 'version'
    
    # DEPLOY TO PROD
    - name: Deploy to prod
      id: proddeploy
      run: |
        # ---- get the oc namespace name and set the namespace, verify that the project
        #      that is being pointed to is the correct one or raise an error
        OC_NAMESPACE_NAMES_CONFIG_MAP=namespaces-cm
        OCPRODNAMESPACE=$(oc get configmap $OC_NAMESPACE_NAMES_CONFIG_MAP  -o json | jq .data.prod | tr -d '"')
        echo namespace $OCPRODNAMESPACE
        oc project $OCPRODNAMESPACE
        project=$(oc project --short=true)
        if [ "$project" != "$OCDEVNAMESPACE" ]
          then 
              exit 1
        fi

        EMAIL=${{ steps.retrieveimagetag.outputs.EMAIL }}
        DOCKER_VERSION_TAG=${{ steps.retrieveimagetag.outputs.DOCKER_VERSION_TAG }}
        IMAGE_REGISTRY=${{ steps.retrieveimagetag.outputs.IMAGE_REGISTRY }}
        REPONAME=${{ steps.retrieveimagetag.outputs.REPONAME }}

        # extract deploy name from the template
        helm upgrade $REPONAME ./helm-charts --install \
           --set app_name=$REPONAME \
           --set env=prd \
           --set app_image_pull_secret_params.name=github-imagepull-secrets \
           --set app_image_pull_secret_params.imagetag=$DOCKER_VERSION_TAG \
           --set app_image_pull_secret_params.registry=$IMAGE_REGISTRY


